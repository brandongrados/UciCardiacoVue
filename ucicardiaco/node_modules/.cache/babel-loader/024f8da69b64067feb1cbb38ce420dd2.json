{"remainingRequest":"C:\\Users\\bjavi\\source\\repos\\UciCardiacoVue\\ucicardiaco\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\bjavi\\source\\repos\\UciCardiacoVue\\ucicardiaco\\node_modules\\vuetify\\lib\\components\\VMenu\\mixins\\menu-position.js","dependencies":[{"path":"C:\\Users\\bjavi\\source\\repos\\UciCardiacoVue\\ucicardiaco\\node_modules\\vuetify\\lib\\components\\VMenu\\mixins\\menu-position.js","mtime":499162500000},{"path":"C:\\Users\\bjavi\\source\\repos\\UciCardiacoVue\\ucicardiaco\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\bjavi\\source\\repos\\UciCardiacoVue\\ucicardiaco\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.array.from\";\nimport \"core-js/modules/es6.array.find-index\";\n\n/**\n * Menu position\n *\n * @mixin\n *\n * Used for calculating an automatic position (used for VSelect)\n * Will position the VMenu content properly over the VSelect\n */\n\n/* @vue/component */\nexport default {\n  methods: {\n    // Revisit this\n    calculateScroll: function calculateScroll() {\n      if (this.selectedIndex === null) return;\n      var scrollTop = 0;\n\n      if (this.selectedIndex >= this.stopIndex) {\n        scrollTop = this.$refs.content.scrollHeight;\n      } else if (this.selectedIndex > this.startIndex) {\n        scrollTop = // Top position of selected item\n        this.selectedIndex * this.tileHeight + // Remove half of a tile's height\n        this.tileHeight / 2 + // Account for padding offset on lists\n        this.defaultOffset / 2 - // Half of the auto content's height\n        100;\n      }\n\n      if (this.$refs.content) {\n        this.$refs.content.scrollTop = scrollTop;\n      }\n    },\n    calcLeftAuto: function calcLeftAuto() {\n      if (this.isAttached) return 0;\n      return parseInt(this.dimensions.activator.left - this.defaultOffset * 2);\n    },\n    calcTopAuto: function calcTopAuto() {\n      var selectedIndex = Array.from(this.tiles).findIndex(function (n) {\n        return n.classList.contains('v-list__tile--active');\n      });\n\n      if (selectedIndex === -1) {\n        this.selectedIndex = null;\n        return this.computedTop;\n      }\n\n      this.selectedIndex = selectedIndex;\n      this.stopIndex = this.tiles.length > 4 ? this.tiles.length - 4 : this.tiles.length;\n      var additionalOffset = this.defaultOffset;\n      var offsetPadding = void 0; // Menu should be centered\n\n      if (selectedIndex > this.startIndex && selectedIndex < this.stopIndex) {\n        offsetPadding = 1.5 * this.tileHeight; // Menu should be offset top\n      } else if (selectedIndex >= this.stopIndex) {\n        // Being offset top means\n        // we have to account for top\n        // and bottom list padding\n        additionalOffset *= 2;\n        offsetPadding = (selectedIndex - this.stopIndex) * this.tileHeight; // Menu should be offset bottom\n      } else {\n        offsetPadding = selectedIndex * this.tileHeight;\n      }\n\n      return this.computedTop + additionalOffset - offsetPadding - this.tileHeight / 2;\n    }\n  }\n};",{"version":3,"sources":["../../../../src/components/VMenu/mixins/menu-position.js"],"names":[],"mappings":";;;;;;;;;;;;;AAQA;AACA,eAAe;AACb,EAAA,OAAA,EAAS;AACP;AACA,IAAA,eAFO,EAAA,SAAA,eAAA,GAEQ;AACb,UAAI,KAAA,aAAA,KAAJ,IAAA,EAAiC;AAEjC,UAAI,SAAA,GAAJ,CAAA;;AAEA,UAAI,KAAA,aAAA,IAAsB,KAA1B,SAAA,EAA0C;AACxC,QAAA,SAAA,GAAY,KAAA,KAAA,CAAA,OAAA,CAAZ,YAAA;AADF,OAAA,MAEO,IAAI,KAAA,aAAA,GAAqB,KAAzB,UAAA,EAA0C;AAC/C,QAAA,SAAA,GACE;AACC,aAAA,aAAA,GAAqB,KAAtB,UAAC,GACD;AACC,aAAA,UAAA,GAFD,CAAC,GAGD;AACC,aAAA,aAAA,GAJD,CAAC,GAKD;AAPF,WAAA;AAUD;;AAED,UAAI,KAAA,KAAA,CAAJ,OAAA,EAAwB;AACtB,aAAA,KAAA,CAAA,OAAA,CAAA,SAAA,GAAA,SAAA;AACD;AAxBI,KAAA;AA0BP,IAAA,YA1BO,EAAA,SAAA,YAAA,GA0BK;AACV,UAAI,KAAJ,UAAA,EAAqB,OAAA,CAAA;AAErB,aAAO,QAAA,CAAS,KAAA,UAAA,CAAA,SAAA,CAAA,IAAA,GAAiC,KAAA,aAAA,GAAjD,CAAO,CAAP;AA7BK,KAAA;AA+BP,IAAA,WA/BO,EAAA,SAAA,WAAA,GA+BI;AACT,UAAM,aAAA,GAAgB,KAAA,CAAA,IAAA,CAAW,KAAX,KAAA,EAAA,SAAA,CACT,UAAA,CAAA,EAAA;AAAA,eAAK,CAAA,CAAA,SAAA,CAAA,QAAA,CAAL,sBAAK,CAAL;AADb,OAAsB,CAAtB;;AAGA,UAAI,aAAA,KAAkB,CAAtB,CAAA,EAA0B;AACxB,aAAA,aAAA,GAAA,IAAA;AAEA,eAAO,KAAP,WAAA;AACD;;AAED,WAAA,aAAA,GAAA,aAAA;AACA,WAAA,SAAA,GAAiB,KAAA,KAAA,CAAA,MAAA,GAAA,CAAA,GACb,KAAA,KAAA,CAAA,MAAA,GADa,CAAA,GAEb,KAAA,KAAA,CAFJ,MAAA;AAGA,UAAI,gBAAA,GAAmB,KAAvB,aAAA;AACA,UAAI,aAAA,GAAA,KAAJ,CAAA,CAfS,CAiBT;;AACA,UAAI,aAAA,GAAgB,KAAhB,UAAA,IACF,aAAA,GAAgB,KADlB,SAAA,EAEE;AACA,QAAA,aAAA,GAAgB,MAAM,KAAtB,UAAA,CADA,CAEF;AAJA,OAAA,MAKO,IAAI,aAAA,IAAiB,KAArB,SAAA,EAAqC;AAC1C;AACA;AACA;AACA,QAAA,gBAAA,IAAA,CAAA;AACA,QAAA,aAAA,GAAgB,CAAC,aAAA,GAAgB,KAAjB,SAAA,IAAmC,KAAnD,UAAA,CAL0C,CAM5C;AANO,OAAA,MAOA;AACL,QAAA,aAAA,GAAgB,aAAA,GAAgB,KAAhC,UAAA;AACD;;AAED,aACE,KAAA,WAAA,GAAA,gBAAA,GAAA,aAAA,GAGC,KAAA,UAAA,GAJH,CAAA;AAMD;AAvEM;AADI,CAAf","sourcesContent":["/**\n * Menu position\n *\n * @mixin\n *\n * Used for calculating an automatic position (used for VSelect)\n * Will position the VMenu content properly over the VSelect\n */\n/* @vue/component */\nexport default {\n  methods: {\n    // Revisit this\n    calculateScroll () {\n      if (this.selectedIndex === null) return\n\n      let scrollTop = 0\n\n      if (this.selectedIndex >= this.stopIndex) {\n        scrollTop = this.$refs.content.scrollHeight\n      } else if (this.selectedIndex > this.startIndex) {\n        scrollTop = (\n          // Top position of selected item\n          (this.selectedIndex * this.tileHeight) +\n          // Remove half of a tile's height\n          (this.tileHeight / 2) +\n          // Account for padding offset on lists\n          (this.defaultOffset / 2) -\n          // Half of the auto content's height\n          100\n        )\n      }\n\n      if (this.$refs.content) {\n        this.$refs.content.scrollTop = scrollTop\n      }\n    },\n    calcLeftAuto () {\n      if (this.isAttached) return 0\n\n      return parseInt(this.dimensions.activator.left - this.defaultOffset * 2)\n    },\n    calcTopAuto () {\n      const selectedIndex = Array.from(this.tiles)\n        .findIndex(n => n.classList.contains('v-list__tile--active'))\n\n      if (selectedIndex === -1) {\n        this.selectedIndex = null\n\n        return this.computedTop\n      }\n\n      this.selectedIndex = selectedIndex\n      this.stopIndex = this.tiles.length > 4\n        ? this.tiles.length - 4\n        : this.tiles.length\n      let additionalOffset = this.defaultOffset\n      let offsetPadding\n\n      // Menu should be centered\n      if (selectedIndex > this.startIndex &&\n        selectedIndex < this.stopIndex\n      ) {\n        offsetPadding = 1.5 * this.tileHeight\n      // Menu should be offset top\n      } else if (selectedIndex >= this.stopIndex) {\n        // Being offset top means\n        // we have to account for top\n        // and bottom list padding\n        additionalOffset *= 2\n        offsetPadding = (selectedIndex - this.stopIndex) * this.tileHeight\n      // Menu should be offset bottom\n      } else {\n        offsetPadding = selectedIndex * this.tileHeight\n      }\n\n      return (\n        this.computedTop +\n        additionalOffset -\n        offsetPadding -\n        (this.tileHeight / 2)\n      )\n    }\n  }\n}\n"],"sourceRoot":""}]}