{"remainingRequest":"C:\\Users\\manue\\Desktop\\UciCardiacoVue\\ucicardiaco\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\manue\\Desktop\\UciCardiacoVue\\ucicardiaco\\node_modules\\vuetify\\lib\\mixins\\maskable.js","dependencies":[{"path":"C:\\Users\\manue\\Desktop\\UciCardiacoVue\\ucicardiaco\\node_modules\\vuetify\\lib\\mixins\\maskable.js","mtime":1589651993149},{"path":"C:\\Users\\manue\\Desktop\\UciCardiacoVue\\ucicardiaco\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1589651934081},{"path":"C:\\Users\\manue\\Desktop\\UciCardiacoVue\\ucicardiaco\\node_modules\\babel-loader\\lib\\index.js","mtime":1589651931824}],"contextDependencies":[],"result":["import \"core-js/modules/es6.regexp.split\";\n\n/**\r\n * Maskable\r\n *\r\n * @mixin\r\n *\r\n * Creates an input mask that is\r\n * generated from a masked str\r\n *\r\n * Example: mask=\"#### #### #### ####\"\r\n */\nimport { isMaskDelimiter, maskText as _maskText, unmaskText as _unmaskText } from '../util/mask';\n/* @vue/component */\n\nexport default {\n  name: 'maskable',\n  props: {\n    dontFillMaskBlanks: Boolean,\n    mask: {\n      type: [Object, String],\n      default: null\n    },\n    returnMaskedValue: Boolean\n  },\n  data: function data() {\n    return {\n      selection: 0,\n      lazySelection: 0,\n      preDefined: {\n        'credit-card': '#### - #### - #### - ####',\n        'date': '##/##/####',\n        'date-with-time': '##/##/#### ##:##',\n        'phone': '(###) ### - ####',\n        'social': '###-##-####',\n        'time': '##:##',\n        'time-with-seconds': '##:##:##'\n      }\n    };\n  },\n  computed: {\n    masked: function masked() {\n      var preDefined = this.preDefined[this.mask];\n      var mask = preDefined || this.mask || '';\n      return mask.split('');\n    }\n  },\n  watch: {\n    /**\r\n     * Make sure the cursor is in the correct\r\n     * location when the mask changes\r\n     */\n    mask: function mask() {\n      var _this = this;\n\n      if (!this.$refs.input) return;\n      var oldValue = this.$refs.input.value;\n      var newValue = this.maskText(_unmaskText(this.lazyValue));\n      var position = 0;\n      var selection = this.selection;\n\n      for (var index = 0; index < selection; index++) {\n        isMaskDelimiter(oldValue[index]) || position++;\n      }\n\n      selection = 0;\n\n      if (newValue) {\n        for (var _index = 0; _index < newValue.length; _index++) {\n          isMaskDelimiter(newValue[_index]) || position--;\n          selection++;\n          if (position <= 0) break;\n        }\n      }\n\n      this.$nextTick(function () {\n        _this.$refs.input.value = newValue;\n\n        _this.setCaretPosition(selection);\n      });\n    }\n  },\n  beforeMount: function beforeMount() {\n    if (!this.mask || this.value == null || !this.returnMaskedValue) return;\n    var value = this.maskText(this.value); // See if masked value does not\n    // match the user given value\n\n    if (value === this.value) return;\n    this.$emit('input', value);\n  },\n  methods: {\n    setCaretPosition: function setCaretPosition(selection) {\n      var _this2 = this;\n\n      this.selection = selection;\n      window.setTimeout(function () {\n        _this2.$refs.input && _this2.$refs.input.setSelectionRange(_this2.selection, _this2.selection);\n      }, 0);\n    },\n    updateRange: function updateRange() {\n      if (!this.$refs.input) return;\n      var newValue = this.maskText(this.lazyValue);\n      var selection = 0;\n      this.$refs.input.value = newValue;\n\n      if (newValue) {\n        for (var index = 0; index < newValue.length; index++) {\n          if (this.lazySelection <= 0) break;\n          isMaskDelimiter(newValue[index]) || this.lazySelection--;\n          selection++;\n        }\n      }\n\n      this.setCaretPosition(selection); // this.$emit() must occur only when all internal values are correct\n\n      this.$emit('input', this.returnMaskedValue ? this.$refs.input.value : this.lazyValue);\n    },\n    maskText: function maskText(text) {\n      return this.mask ? _maskText(text, this.masked, this.dontFillMaskBlanks) : text;\n    },\n    unmaskText: function unmaskText(text) {\n      return this.mask && !this.returnMaskedValue ? _unmaskText(text) : text;\n    },\n    // When the input changes and is\n    // re-created, ensure that the\n    // caret location is correct\n    setSelectionRange: function setSelectionRange() {\n      this.$nextTick(this.updateRange);\n    },\n    resetSelections: function resetSelections(input) {\n      if (!input.selectionEnd) return;\n      this.selection = input.selectionEnd;\n      this.lazySelection = 0;\n\n      for (var index = 0; index < this.selection; index++) {\n        isMaskDelimiter(input.value[index]) || this.lazySelection++;\n      }\n    }\n  }\n};",{"version":3,"sources":["../../src/mixins/maskable.js"],"names":[],"mappings":"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","sourcesContent":["/**\n * Maskable\n *\n * @mixin\n *\n * Creates an input mask that is\n * generated from a masked str\n *\n * Example: mask=\"#### #### #### ####\"\n */\n\nimport {\n  isMaskDelimiter,\n  maskText,\n  unmaskText\n} from '../util/mask'\n\n/* @vue/component */\nexport default {\n  name: 'maskable',\n\n  props: {\n    dontFillMaskBlanks: Boolean,\n    mask: {\n      type: [Object, String],\n      default: null\n    },\n    returnMaskedValue: Boolean\n  },\n\n  data: () => ({\n    selection: 0,\n    lazySelection: 0,\n    preDefined: {\n      'credit-card': '#### - #### - #### - ####',\n      'date': '##/##/####',\n      'date-with-time': '##/##/#### ##:##',\n      'phone': '(###) ### - ####',\n      'social': '###-##-####',\n      'time': '##:##',\n      'time-with-seconds': '##:##:##'\n    }\n  }),\n\n  computed: {\n    masked () {\n      const preDefined = this.preDefined[this.mask]\n      const mask = preDefined || this.mask || ''\n\n      return mask.split('')\n    }\n  },\n\n  watch: {\n    /**\n     * Make sure the cursor is in the correct\n     * location when the mask changes\n     */\n    mask () {\n      if (!this.$refs.input) return\n\n      const oldValue = this.$refs.input.value\n      const newValue = this.maskText(unmaskText(this.lazyValue))\n      let position = 0\n      let selection = this.selection\n\n      for (let index = 0; index < selection; index++) {\n        isMaskDelimiter(oldValue[index]) || position++\n      }\n\n      selection = 0\n      if (newValue) {\n        for (let index = 0; index < newValue.length; index++) {\n          isMaskDelimiter(newValue[index]) || position--\n          selection++\n          if (position <= 0) break\n        }\n      }\n\n      this.$nextTick(() => {\n        this.$refs.input.value = newValue\n        this.setCaretPosition(selection)\n      })\n    }\n  },\n\n  beforeMount () {\n    if (!this.mask ||\n      this.value == null ||\n      !this.returnMaskedValue\n    ) return\n\n    const value = this.maskText(this.value)\n\n    // See if masked value does not\n    // match the user given value\n    if (value === this.value) return\n\n    this.$emit('input', value)\n  },\n\n  methods: {\n    setCaretPosition (selection) {\n      this.selection = selection\n      window.setTimeout(() => {\n        this.$refs.input && this.$refs.input.setSelectionRange(this.selection, this.selection)\n      }, 0)\n    },\n    updateRange () {\n      if (!this.$refs.input) return\n\n      const newValue = this.maskText(this.lazyValue)\n      let selection = 0\n\n      this.$refs.input.value = newValue\n      if (newValue) {\n        for (let index = 0; index < newValue.length; index++) {\n          if (this.lazySelection <= 0) break\n          isMaskDelimiter(newValue[index]) || this.lazySelection--\n          selection++\n        }\n      }\n\n      this.setCaretPosition(selection)\n      // this.$emit() must occur only when all internal values are correct\n      this.$emit('input', this.returnMaskedValue ? this.$refs.input.value : this.lazyValue)\n    },\n    maskText (text) {\n      return this.mask ? maskText(text, this.masked, this.dontFillMaskBlanks) : text\n    },\n    unmaskText (text) {\n      return this.mask && !this.returnMaskedValue ? unmaskText(text) : text\n    },\n    // When the input changes and is\n    // re-created, ensure that the\n    // caret location is correct\n    setSelectionRange () {\n      this.$nextTick(this.updateRange)\n    },\n    resetSelections (input) {\n      if (!input.selectionEnd) return\n      this.selection = input.selectionEnd\n      this.lazySelection = 0\n\n      for (let index = 0; index < this.selection; index++) {\n        isMaskDelimiter(input.value[index]) || this.lazySelection++\n      }\n    }\n  }\n}\n"],"sourceRoot":""}]}