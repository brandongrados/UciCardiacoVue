{"remainingRequest":"C:\\Users\\manue\\Desktop\\UciCardiacoVue\\ucicardiaco\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\manue\\Desktop\\UciCardiacoVue\\ucicardiaco\\node_modules\\vuetify\\lib\\components\\VAutocomplete\\VAutocomplete.js","dependencies":[{"path":"C:\\Users\\manue\\Desktop\\UciCardiacoVue\\ucicardiaco\\node_modules\\vuetify\\lib\\components\\VAutocomplete\\VAutocomplete.js","mtime":1590258018571},{"path":"C:\\Users\\manue\\Desktop\\UciCardiacoVue\\ucicardiaco\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1590257978015},{"path":"C:\\Users\\manue\\Desktop\\UciCardiacoVue\\ucicardiaco\\node_modules\\babel-loader\\lib\\index.js","mtime":1590257976698}],"contextDependencies":[],"result":["import \"core-js/modules/es7.array.includes\";\nimport \"core-js/modules/es6.string.includes\";\nimport \"core-js/modules/es6.array.find\";\nimport \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/es6.object.assign\";\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n}; // Styles\n\n\nimport '../../../src/stylus/components/_autocompletes.styl'; // Extensions\n\nimport VSelect, { defaultMenuProps as VSelectMenuProps } from '../VSelect/VSelect';\nimport VTextField from '../VTextField/VTextField'; // Utils\n\nimport { keyCodes } from '../../util/helpers';\n\nvar defaultMenuProps = _extends({}, VSelectMenuProps, {\n  offsetY: true,\n  offsetOverflow: true,\n  transition: false\n});\n/* @vue/component */\n\n\nexport default {\n  name: 'v-autocomplete',\n  extends: VSelect,\n  props: {\n    allowOverflow: {\n      type: Boolean,\n      default: true\n    },\n    browserAutocomplete: {\n      type: String,\n      default: 'off'\n    },\n    filter: {\n      type: Function,\n      default: function _default(item, queryText, itemText) {\n        var hasValue = function hasValue(val) {\n          return val != null ? val : '';\n        };\n\n        var text = hasValue(itemText);\n        var query = hasValue(queryText);\n        return text.toString().toLowerCase().indexOf(query.toString().toLowerCase()) > -1;\n      }\n    },\n    hideNoData: Boolean,\n    noFilter: Boolean,\n    searchInput: {\n      default: undefined\n    },\n    menuProps: {\n      type: VSelect.props.menuProps.type,\n      default: function _default() {\n        return defaultMenuProps;\n      }\n    }\n  },\n  data: function data(vm) {\n    return {\n      attrsInput: null,\n      lazySearch: vm.searchInput\n    };\n  },\n  computed: {\n    classes: function classes() {\n      return Object.assign({}, VSelect.computed.classes.call(this), {\n        'v-autocomplete': true,\n        'v-autocomplete--is-selecting-index': this.selectedIndex > -1\n      });\n    },\n    computedItems: function computedItems() {\n      return this.filteredItems;\n    },\n    displayedItemsCount: function displayedItemsCount() {\n      return this.hideSelected ? this.filteredItems.length - this.selectedItems.length : this.filteredItems.length;\n    },\n\n    /**\r\n     * The range of the current input text\r\n     *\r\n     * @return {Number}\r\n     */\n    currentRange: function currentRange() {\n      if (this.selectedItem == null) return 0;\n      return this.getText(this.selectedItem).toString().length;\n    },\n    filteredItems: function filteredItems() {\n      var _this = this;\n\n      if (!this.isSearching || this.noFilter) return this.allItems;\n      return this.allItems.filter(function (i) {\n        return _this.filter(i, _this.internalSearch, _this.getText(i));\n      });\n    },\n    internalSearch: {\n      get: function get() {\n        return this.lazySearch;\n      },\n      set: function set(val) {\n        this.lazySearch = val;\n        this.$emit('update:searchInput', val);\n      }\n    },\n    isAnyValueAllowed: function isAnyValueAllowed() {\n      return false;\n    },\n    isDirty: function isDirty() {\n      return this.searchIsDirty || this.selectedItems.length > 0;\n    },\n    isSearching: function isSearching() {\n      if (this.multiple) return this.searchIsDirty;\n      return this.searchIsDirty && this.internalSearch !== this.getText(this.selectedItem);\n    },\n    menuCanShow: function menuCanShow() {\n      if (!this.isFocused) return false;\n      return this.displayedItemsCount > 0 || !this.hideNoData;\n    },\n    $_menuProps: function $_menuProps() {\n      var props = VSelect.computed.$_menuProps.call(this);\n      props.contentClass = ('v-autocomplete__content ' + (props.contentClass || '')).trim();\n      return _extends({}, defaultMenuProps, props);\n    },\n    searchIsDirty: function searchIsDirty() {\n      return this.internalSearch != null && this.internalSearch !== '';\n    },\n    selectedItem: function selectedItem() {\n      var _this2 = this;\n\n      if (this.multiple) return null;\n      return this.selectedItems.find(function (i) {\n        return _this2.valueComparator(_this2.getValue(i), _this2.getValue(_this2.internalValue));\n      });\n    },\n    listData: function listData() {\n      var data = VSelect.computed.listData.call(this);\n      Object.assign(data.props, {\n        items: this.virtualizedItems,\n        noFilter: this.noFilter || !this.isSearching || !this.filteredItems.length,\n        searchInput: this.internalSearch\n      });\n      return data;\n    }\n  },\n  watch: {\n    filteredItems: function filteredItems(val) {\n      this.onFilteredItemsChanged(val);\n    },\n    internalValue: function internalValue() {\n      this.setSearch();\n    },\n    isFocused: function isFocused(val) {\n      if (val) {\n        this.$refs.input && this.$refs.input.select();\n      } else {\n        this.updateSelf();\n      }\n    },\n    isMenuActive: function isMenuActive(val) {\n      if (val || !this.hasSlot) return;\n      this.lazySearch = null;\n    },\n    items: function items(val, oldVal) {\n      // If we are focused, the menu\n      // is not active, hide no data is enabled,\n      // and items change\n      // User is probably async loading\n      // items, try to activate the menu\n      if (!(oldVal && oldVal.length) && this.hideNoData && this.isFocused && !this.isMenuActive && val.length) this.activateMenu();\n    },\n    searchInput: function searchInput(val) {\n      this.lazySearch = val;\n    },\n    internalSearch: function internalSearch(val) {\n      this.onInternalSearchChanged(val);\n    }\n  },\n  created: function created() {\n    this.setSearch();\n  },\n  methods: {\n    onFilteredItemsChanged: function onFilteredItemsChanged(val) {\n      var _this3 = this;\n\n      this.setMenuIndex(-1);\n      this.$nextTick(function () {\n        _this3.setMenuIndex(val.length === 1 ? 0 : -1);\n      });\n    },\n    onInternalSearchChanged: function onInternalSearchChanged(val) {\n      this.updateMenuDimensions();\n    },\n    updateMenuDimensions: function updateMenuDimensions() {\n      if (this.isMenuActive && this.$refs.menu) {\n        this.$refs.menu.updateDimensions();\n      }\n    },\n    changeSelectedIndex: function changeSelectedIndex(keyCode) {\n      // Do not allow changing of selectedIndex\n      // when search is dirty\n      if (this.searchIsDirty) return;\n      if (![keyCodes.backspace, keyCodes.left, keyCodes.right, keyCodes.delete].includes(keyCode)) return;\n      var indexes = this.selectedItems.length - 1;\n\n      if (keyCode === keyCodes.left) {\n        this.selectedIndex = this.selectedIndex === -1 ? indexes : this.selectedIndex - 1;\n      } else if (keyCode === keyCodes.right) {\n        this.selectedIndex = this.selectedIndex >= indexes ? -1 : this.selectedIndex + 1;\n      } else if (this.selectedIndex === -1) {\n        this.selectedIndex = indexes;\n        return;\n      }\n\n      var currentItem = this.selectedItems[this.selectedIndex];\n\n      if ([keyCodes.backspace, keyCodes.delete].includes(keyCode) && !this.getDisabled(currentItem)) {\n        var newIndex = this.selectedIndex === indexes ? this.selectedIndex - 1 : this.selectedItems[this.selectedIndex + 1] ? this.selectedIndex : -1;\n\n        if (newIndex === -1) {\n          this.setValue(this.multiple ? [] : undefined);\n        } else {\n          this.selectItem(currentItem);\n        }\n\n        this.selectedIndex = newIndex;\n      }\n    },\n    clearableCallback: function clearableCallback() {\n      this.internalSearch = undefined;\n      VSelect.methods.clearableCallback.call(this);\n    },\n    genInput: function genInput() {\n      var input = VTextField.methods.genInput.call(this);\n      input.data.attrs.role = 'combobox';\n      input.data.domProps.value = this.internalSearch;\n      return input;\n    },\n    genSelections: function genSelections() {\n      return this.hasSlot || this.multiple ? VSelect.methods.genSelections.call(this) : [];\n    },\n    onClick: function onClick() {\n      if (this.isDisabled) return;\n      this.selectedIndex > -1 ? this.selectedIndex = -1 : this.onFocus();\n      this.activateMenu();\n    },\n    onEnterDown: function onEnterDown() {// Avoid invoking this method\n      // will cause updateSelf to\n      // be called emptying search\n    },\n    onInput: function onInput(e) {\n      if (this.selectedIndex > -1) return; // If typing and menu is not currently active\n\n      if (e.target.value) {\n        this.activateMenu();\n        if (!this.isAnyValueAllowed) this.setMenuIndex(0);\n      }\n\n      this.mask && this.resetSelections(e.target);\n      this.internalSearch = e.target.value;\n      this.badInput = e.target.validity && e.target.validity.badInput;\n    },\n    onKeyDown: function onKeyDown(e) {\n      var keyCode = e.keyCode;\n      VSelect.methods.onKeyDown.call(this, e); // The ordering is important here\n      // allows new value to be updated\n      // and then moves the index to the\n      // proper location\n\n      this.changeSelectedIndex(keyCode);\n    },\n    onTabDown: function onTabDown(e) {\n      VSelect.methods.onTabDown.call(this, e);\n      this.updateSelf();\n    },\n    setSelectedItems: function setSelectedItems() {\n      VSelect.methods.setSelectedItems.call(this); // #4273 Don't replace if searching\n      // #4403 Don't replace if focused\n\n      if (!this.isFocused) this.setSearch();\n    },\n    setSearch: function setSearch() {\n      var _this4 = this; // Wait for nextTick so selectedItem\n      // has had time to update\n\n\n      this.$nextTick(function () {\n        _this4.internalSearch = !_this4.selectedItems.length || _this4.multiple || _this4.hasSlot ? null : _this4.getText(_this4.selectedItem);\n      });\n    },\n    updateSelf: function updateSelf() {\n      this.updateAutocomplete();\n    },\n    updateAutocomplete: function updateAutocomplete() {\n      if (!this.searchIsDirty && !this.internalValue) return;\n\n      if (!this.valueComparator(this.internalSearch, this.getValue(this.internalValue))) {\n        this.setSearch();\n      }\n    }\n  }\n};",{"version":3,"sources":["../../../src/components/VAutocomplete/VAutocomplete.js"],"names":[],"mappings":"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","sourcesContent":["// Styles\nimport '../../stylus/components/_autocompletes.styl'\n\n// Extensions\nimport VSelect, { defaultMenuProps as VSelectMenuProps } from '../VSelect/VSelect'\nimport VTextField from '../VTextField/VTextField'\n\n// Utils\nimport { keyCodes } from '../../util/helpers'\n\nconst defaultMenuProps = {\n  ...VSelectMenuProps,\n  offsetY: true,\n  offsetOverflow: true,\n  transition: false\n}\n\n/* @vue/component */\nexport default {\n  name: 'v-autocomplete',\n\n  extends: VSelect,\n\n  props: {\n    allowOverflow: {\n      type: Boolean,\n      default: true\n    },\n    browserAutocomplete: {\n      type: String,\n      default: 'off'\n    },\n    filter: {\n      type: Function,\n      default: (item, queryText, itemText) => {\n        const hasValue = val => val != null ? val : ''\n\n        const text = hasValue(itemText)\n        const query = hasValue(queryText)\n\n        return text.toString()\n          .toLowerCase()\n          .indexOf(query.toString().toLowerCase()) > -1\n      }\n    },\n    hideNoData: Boolean,\n    noFilter: Boolean,\n    searchInput: {\n      default: undefined\n    },\n    menuProps: {\n      type: VSelect.props.menuProps.type,\n      default: () => defaultMenuProps\n    }\n  },\n\n  data: vm => ({\n    attrsInput: null,\n    lazySearch: vm.searchInput\n  }),\n\n  computed: {\n    classes () {\n      return Object.assign({}, VSelect.computed.classes.call(this), {\n        'v-autocomplete': true,\n        'v-autocomplete--is-selecting-index': this.selectedIndex > -1\n      })\n    },\n    computedItems () {\n      return this.filteredItems\n    },\n    displayedItemsCount () {\n      return this.hideSelected\n        ? this.filteredItems.length - this.selectedItems.length\n        : this.filteredItems.length\n    },\n    /**\n     * The range of the current input text\n     *\n     * @return {Number}\n     */\n    currentRange () {\n      if (this.selectedItem == null) return 0\n\n      return this.getText(this.selectedItem).toString().length\n    },\n    filteredItems () {\n      if (!this.isSearching || this.noFilter) return this.allItems\n\n      return this.allItems.filter(i => this.filter(i, this.internalSearch, this.getText(i)))\n    },\n    internalSearch: {\n      get () {\n        return this.lazySearch\n      },\n      set (val) {\n        this.lazySearch = val\n\n        this.$emit('update:searchInput', val)\n      }\n    },\n    isAnyValueAllowed () {\n      return false\n    },\n    isDirty () {\n      return this.searchIsDirty || this.selectedItems.length > 0\n    },\n    isSearching () {\n      if (this.multiple) return this.searchIsDirty\n\n      return (\n        this.searchIsDirty &&\n        this.internalSearch !== this.getText(this.selectedItem)\n      )\n    },\n    menuCanShow () {\n      if (!this.isFocused) return false\n\n      return (this.displayedItemsCount > 0) || !this.hideNoData\n    },\n    $_menuProps () {\n      const props = VSelect.computed.$_menuProps.call(this)\n      props.contentClass = `v-autocomplete__content ${props.contentClass || ''}`.trim()\n      return {\n        ...defaultMenuProps,\n        ...props\n      }\n    },\n    searchIsDirty () {\n      return this.internalSearch != null &&\n        this.internalSearch !== ''\n    },\n    selectedItem () {\n      if (this.multiple) return null\n\n      return this.selectedItems.find(i => {\n        return this.valueComparator(this.getValue(i), this.getValue(this.internalValue))\n      })\n    },\n    listData () {\n      const data = VSelect.computed.listData.call(this)\n\n      Object.assign(data.props, {\n        items: this.virtualizedItems,\n        noFilter: (\n          this.noFilter ||\n          !this.isSearching ||\n          !this.filteredItems.length\n        ),\n        searchInput: this.internalSearch\n      })\n\n      return data\n    }\n  },\n\n  watch: {\n    filteredItems (val) {\n      this.onFilteredItemsChanged(val)\n    },\n    internalValue () {\n      this.setSearch()\n    },\n    isFocused (val) {\n      if (val) {\n        this.$refs.input &&\n          this.$refs.input.select()\n      } else {\n        this.updateSelf()\n      }\n    },\n    isMenuActive (val) {\n      if (val || !this.hasSlot) return\n\n      this.lazySearch = null\n    },\n    items (val, oldVal) {\n      // If we are focused, the menu\n      // is not active, hide no data is enabled,\n      // and items change\n      // User is probably async loading\n      // items, try to activate the menu\n      if (\n        !(oldVal && oldVal.length) &&\n        this.hideNoData &&\n        this.isFocused &&\n        !this.isMenuActive &&\n        val.length\n      ) this.activateMenu()\n    },\n    searchInput (val) {\n      this.lazySearch = val\n    },\n    internalSearch (val) {\n      this.onInternalSearchChanged(val)\n    }\n  },\n\n  created () {\n    this.setSearch()\n  },\n\n  methods: {\n    onFilteredItemsChanged (val) {\n      this.setMenuIndex(-1)\n\n      this.$nextTick(() => {\n        this.setMenuIndex(val.length === 1 ? 0 : -1)\n      })\n    },\n    onInternalSearchChanged (val) {\n      this.updateMenuDimensions()\n    },\n    updateMenuDimensions () {\n      if (this.isMenuActive &&\n        this.$refs.menu\n      ) {\n        this.$refs.menu.updateDimensions()\n      }\n    },\n    changeSelectedIndex (keyCode) {\n      // Do not allow changing of selectedIndex\n      // when search is dirty\n      if (this.searchIsDirty) return\n\n      if (![\n        keyCodes.backspace,\n        keyCodes.left,\n        keyCodes.right,\n        keyCodes.delete\n      ].includes(keyCode)) return\n\n      const indexes = this.selectedItems.length - 1\n\n      if (keyCode === keyCodes.left) {\n        this.selectedIndex = this.selectedIndex === -1\n          ? indexes\n          : this.selectedIndex - 1\n      } else if (keyCode === keyCodes.right) {\n        this.selectedIndex = this.selectedIndex >= indexes\n          ? -1\n          : this.selectedIndex + 1\n      } else if (this.selectedIndex === -1) {\n        this.selectedIndex = indexes\n        return\n      }\n\n      const currentItem = this.selectedItems[this.selectedIndex]\n\n      if ([\n        keyCodes.backspace,\n        keyCodes.delete\n      ].includes(keyCode) &&\n        !this.getDisabled(currentItem)\n      ) {\n        const newIndex = this.selectedIndex === indexes\n          ? this.selectedIndex - 1\n          : this.selectedItems[this.selectedIndex + 1]\n            ? this.selectedIndex\n            : -1\n\n        if (newIndex === -1) {\n          this.setValue(this.multiple ? [] : undefined)\n        } else {\n          this.selectItem(currentItem)\n        }\n\n        this.selectedIndex = newIndex\n      }\n    },\n    clearableCallback () {\n      this.internalSearch = undefined\n\n      VSelect.methods.clearableCallback.call(this)\n    },\n    genInput () {\n      const input = VTextField.methods.genInput.call(this)\n\n      input.data.attrs.role = 'combobox'\n      input.data.domProps.value = this.internalSearch\n\n      return input\n    },\n    genSelections () {\n      return this.hasSlot || this.multiple\n        ? VSelect.methods.genSelections.call(this)\n        : []\n    },\n    onClick () {\n      if (this.isDisabled) return\n\n      this.selectedIndex > -1\n        ? (this.selectedIndex = -1)\n        : this.onFocus()\n\n      this.activateMenu()\n    },\n    onEnterDown () {\n      // Avoid invoking this method\n      // will cause updateSelf to\n      // be called emptying search\n    },\n    onInput (e) {\n      if (this.selectedIndex > -1) return\n\n      // If typing and menu is not currently active\n      if (e.target.value) {\n        this.activateMenu()\n        if (!this.isAnyValueAllowed) this.setMenuIndex(0)\n      }\n\n      this.mask && this.resetSelections(e.target)\n      this.internalSearch = e.target.value\n      this.badInput = e.target.validity && e.target.validity.badInput\n    },\n    onKeyDown (e) {\n      const keyCode = e.keyCode\n\n      VSelect.methods.onKeyDown.call(this, e)\n\n      // The ordering is important here\n      // allows new value to be updated\n      // and then moves the index to the\n      // proper location\n      this.changeSelectedIndex(keyCode)\n    },\n    onTabDown (e) {\n      VSelect.methods.onTabDown.call(this, e)\n      this.updateSelf()\n    },\n    setSelectedItems () {\n      VSelect.methods.setSelectedItems.call(this)\n\n      // #4273 Don't replace if searching\n      // #4403 Don't replace if focused\n      if (!this.isFocused) this.setSearch()\n    },\n    setSearch () {\n      // Wait for nextTick so selectedItem\n      // has had time to update\n      this.$nextTick(() => {\n        this.internalSearch = (\n          !this.selectedItems.length ||\n          this.multiple ||\n          this.hasSlot\n        )\n          ? null\n          : this.getText(this.selectedItem)\n      })\n    },\n    updateSelf () {\n      this.updateAutocomplete()\n    },\n    updateAutocomplete () {\n      if (!this.searchIsDirty &&\n        !this.internalValue\n      ) return\n\n      if (!this.valueComparator(\n        this.internalSearch,\n        this.getValue(this.internalValue)\n      )) {\n        this.setSearch()\n      }\n    }\n  }\n}\n"],"sourceRoot":""}]}